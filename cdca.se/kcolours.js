// Generated by CoffeeScript 1.6.2
(function() {
  this.kColours = function(imgTag, opts) {
    var almostOne, attempt, bDiff, canvas, ctx, distSq, dupe, gDiff, height, i, mean, means, minDistSq, nearestMean, offset, pixelArr, pixelCount, prevMean, rDiff, randInt, sample, samples, width, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _q, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;

    if (opts == null) {
      opts = {};
    }
    if ((_ref = opts.k) == null) {
      opts.k = 5;
    }
    if ((_ref1 = opts.numSamples) == null) {
      opts.numSamples = 500;
    }
    if ((_ref2 = opts.sampleAttempts) == null) {
      opts.sampleAttempts = opts.numSamples / 2;
    }
    if ((_ref3 = opts.iterations) == null) {
      opts.iterations = 30;
    }
    if (opts.rngSeed != null) {
      Math.seedrandom(opts.rngSeed);
    }
    almostOne = 0.999999999999;
    randInt = function(lt) {
      return Math.floor(Math.random() * almostOne * lt);
    };
    width = imgTag.width, height = imgTag.height;
    canvas = make({
      tag: 'canvas',
      width: width,
      height: height
    });
    ctx = canvas.getContext('2d');
    ctx.drawImage(imgTag, 0, 0);
    pixelArr = (ctx.getImageData(0, 0, width, height)).data;
    pixelCount = width * height;
    samples = (function() {
      var _i, _ref4, _results;

      _results = [];
      for (i = _i = 0, _ref4 = opts.numSamples; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
        offset = randInt(pixelCount) * 4;
        _results.push({
          r: pixelArr[offset],
          g: pixelArr[offset + 1],
          b: pixelArr[offset + 2]
        });
      }
      return _results;
    })();
    means = [];
    for (i = _i = 0, _ref4 = opts.k; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
      for (attempt = _j = 0, _ref5 = opts.sampleAttempts; 0 <= _ref5 ? _j < _ref5 : _j > _ref5; attempt = 0 <= _ref5 ? ++_j : --_j) {
        dupe = false;
        mean = samples[randInt(opts.numSamples)];
        for (_k = 0, _len = means.length; _k < _len; _k++) {
          prevMean = means[_k];
          dupe = mean.r === prevMean.r && mean.g === prevMean.g && mean.b === prevMean.b;
          if (dupe) {
            break;
          }
        }
        if (!dupe) {
          break;
        }
      }
      if (dupe) {
        break;
      }
      means.push(mean);
    }
    for (i = _l = 0, _ref6 = opts.iterations; 0 <= _ref6 ? _l < _ref6 : _l > _ref6; i = 0 <= _ref6 ? ++_l : --_l) {
      for (_m = 0, _len1 = means.length; _m < _len1; _m++) {
        mean = means[_m];
        mean.sampleCount = mean.rSum = mean.gSum = mean.bSum = 0;
      }
      for (_n = 0, _len2 = samples.length; _n < _len2; _n++) {
        sample = samples[_n];
        minDistSq = Infinity;
        for (_o = 0, _len3 = means.length; _o < _len3; _o++) {
          mean = means[_o];
          rDiff = sample.r - mean.r;
          gDiff = sample.g - mean.g;
          bDiff = sample.b - mean.b;
          distSq = rDiff * rDiff + gDiff * gDiff + bDiff * bDiff;
          if (distSq < minDistSq) {
            nearestMean = mean;
            minDistSq = distSq;
          }
        }
        nearestMean.sampleCount += 1;
        nearestMean.rSum += sample.r;
        nearestMean.gSum += sample.g;
        nearestMean.bSum += sample.b;
      }
      for (_p = 0, _len4 = means.length; _p < _len4; _p++) {
        mean = means[_p];
        if (!(mean.sampleCount > 0)) {
          continue;
        }
        mean.r = mean.rSum / mean.sampleCount;
        mean.g = mean.gSum / mean.sampleCount;
        mean.b = mean.bSum / mean.sampleCount;
      }
    }
    means.sort(function(a, b) {
      return a.sampleCount < b.sampleCount;
    });
    _results = [];
    for (_q = 0, _len5 = means.length; _q < _len5; _q++) {
      mean = means[_q];
      _results.push({
        r: Math.round(mean.r),
        g: Math.round(mean.g),
        b: Math.round(mean.b)
      });
    }
    return _results;
  };

}).call(this);

/*
//@ sourceMappingURL=kcolours.map
*/
