// Generated by CoffeeScript 1.8.0
this.KCol = {
  colours: function(opts) {
    var k, mean, means, pixelArr, samples, v, _i, _len, _ref, _results;
    _ref = KCol.defaults;
    for (k in _ref) {
      v = _ref[k];
      if (opts[k] == null) {
        opts[k] = v;
      }
    }
    pixelArr = KCol.pixelArray(opts);
    samples = opts.sampleFunc(pixelArr, opts);
    means = KCol.startingValues(samples, opts);
    if (!(means.length < opts.k)) {
      KCol.iterate(means, samples, opts);
    }
    means.sort(function(a, b) {
      return a.sampleCount < b.sampleCount;
    });
    means = KCol.eliminateSimilar(means, opts);
    _results = [];
    for (_i = 0, _len = means.length; _i < _len; _i++) {
      mean = means[_i];
      _results.push(KCol.rgbRound(mean));
    }
    return _results;
  },
  pixelArray: function(opts) {
    var canvas, ctx, height, pixels, width, _ref, _ref1;
    _ref = opts.img, width = _ref.width, height = _ref.height;
    if (!(((_ref1 = opts.img) != null ? _ref1.width : void 0) > 0)) {
      throw 'Input must be a loaded image';
    }
    canvas = make({
      tag: 'canvas',
      width: width,
      height: height
    });
    ctx = canvas.getContext('2d');
    ctx.drawImage(opts.img, 0, 0);
    pixels = ctx.getImageData(0, 0, width, height);
    return pixels.data;
  },
  randomPixelSamples: function(pixelArr, opts) {
    var i, offset, pixelCount, _i, _ref, _results;
    pixelCount = pixelArr.length / 4;
    _results = [];
    for (i = _i = 0, _ref = opts.numSamples; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      offset = KCol.randInt(pixelCount) * 4;
      _results.push({
        r: pixelArr[offset],
        g: pixelArr[offset + 1],
        b: pixelArr[offset + 2]
      });
    }
    return _results;
  },
  gridwisePixelSamples: function(pixelArr, opts) {
    var aspect, hBandSize, hSamples, height, hs, offset, samples, vBandSize, vSamples, vs, width, x, y, yOffset, _i, _j, _ref;
    _ref = opts.img, width = _ref.width, height = _ref.height;
    aspect = width / height;
    vSamples = Math.round(Math.sqrt(opts.numSamples / aspect));
    hSamples = Math.round(vSamples * aspect);
    vBandSize = height / vSamples;
    hBandSize = width / hSamples;
    samples = [];
    for (vs = _i = 0; 0 <= vSamples ? _i < vSamples : _i > vSamples; vs = 0 <= vSamples ? ++_i : --_i) {
      y = Math.round(vs * vBandSize + vBandSize / 2);
      yOffset = y * width * 4;
      for (hs = _j = 0; 0 <= hSamples ? _j < hSamples : _j > hSamples; hs = 0 <= hSamples ? ++_j : --_j) {
        x = Math.round(hs * hBandSize + hBandSize / 2);
        offset = yOffset + x * 4;
        samples.push({
          r: pixelArr[offset],
          g: pixelArr[offset + 1],
          b: pixelArr[offset + 2]
        });
      }
    }
    return samples;
  },
  startingValues: function(samples, opts) {
    var attempt, dupe, i, mean, means, prevMean, _i, _j, _k, _len, _ref, _ref1;
    means = [];
    for (i = _i = 0, _ref = opts.k; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (attempt = _j = 0, _ref1 = opts.meanAttempts; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; attempt = 0 <= _ref1 ? ++_j : --_j) {
        dupe = false;
        mean = samples[KCol.randInt(samples.length)];
        for (_k = 0, _len = means.length; _k < _len; _k++) {
          prevMean = means[_k];
          dupe = mean.r === prevMean.r && mean.g === prevMean.g && mean.b === prevMean.b;
          if (dupe) {
            break;
          }
        }
        if (!dupe) {
          break;
        }
      }
      if (dupe) {
        break;
      }
      means.push(mean);
    }
    return means;
  },
  iterate: function(means, samples, opts) {
    var bDiff, distSq, gDiff, i, mean, minDistSq, nearestMean, rDiff, sample, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref;
    for (i = _i = 0, _ref = opts.iterations; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      for (_j = 0, _len = means.length; _j < _len; _j++) {
        mean = means[_j];
        mean.sampleCount = mean.rSum = mean.gSum = mean.bSum = 0;
      }
      for (_k = 0, _len1 = samples.length; _k < _len1; _k++) {
        sample = samples[_k];
        minDistSq = Infinity;
        for (_l = 0, _len2 = means.length; _l < _len2; _l++) {
          mean = means[_l];
          rDiff = sample.r - mean.r;
          gDiff = sample.g - mean.g;
          bDiff = sample.b - mean.b;
          distSq = rDiff * rDiff + gDiff * gDiff + bDiff * bDiff;
          if (distSq < minDistSq) {
            nearestMean = mean;
            minDistSq = distSq;
          }
        }
        nearestMean.sampleCount += 1;
        nearestMean.rSum += sample.r;
        nearestMean.gSum += sample.g;
        nearestMean.bSum += sample.b;
      }
      for (_m = 0, _len3 = means.length; _m < _len3; _m++) {
        mean = means[_m];
        if (!(mean.sampleCount > 0)) {
          continue;
        }
        mean.r = mean.rSum / mean.sampleCount;
        mean.g = mean.gSum / mean.sampleCount;
        mean.b = mean.bSum / mean.sampleCount;
      }
    }
    return null;
  },
  eliminateSimilar: function(means, opts) {
    var distinctMeans, i, j, k, mean, prevMean, similar, v, _i, _j, _len, _ref;
    if (opts == null) {
      opts = {};
    }
    _ref = KCol.defaults;
    for (k in _ref) {
      v = _ref[k];
      if (opts[k] == null) {
        opts[k] = v;
      }
    }
    distinctMeans = [];
    for (i = _i = 0, _len = means.length; _i < _len; i = ++_i) {
      mean = means[i];
      similar = false;
      for (j = _j = 0; 0 <= i ? _j < i : _j > i; j = 0 <= i ? ++_j : --_j) {
        prevMean = means[j];
        if (KCol.colourDistance(mean, prevMean) < opts.minDistance) {
          similar = true;
          break;
        }
      }
      if (!similar) {
        distinctMeans.push(mean);
      }
    }
    return distinctMeans;
  },
  randInt: function(lt) {
    return Math.floor(KCol.random() * lt * 0.999999999999);
  },

  /*
  colourDistance: (c1, c2) ->  # 0 - 100, see http://compuphase.com/cmetric.htm
    rMean = (c1.r + c2.r) / 2
    r = c1.r - c2.r
    g = c1.g - c2.g
    b = c1.b - c2.b
    Math.sqrt((2 + rMean / 256) * r * r + 4 * g * g + (2 + (255 - rMean) / 256) * b * b) / 7.64834
   */
  colourDistance: function(c1, c2) {
    var delta, k, lab1, lab2, rgb2xyz, sum, v1, v2, xyz2Lab;
    rgb2xyz = function(rgb1) {
      var k, rgb2, v;
      rgb2 = {};
      for (k in rgb1) {
        v = rgb1[k];
        v /= 255;
        rgb2[k] = v > 0.04045 ? Math.pow((v + 0.055) / 1.055, 2.4) : v / 12.92;
      }
      return {
        x: rgb2.r * 0.4124 + rgb2.g * 0.3576 + rgb2.b * 0.1805,
        y: rgb2.r * 0.2126 + rgb2.g * 0.7152 + rgb2.b * 0.0722,
        z: rgb2.r * 0.0193 + rgb2.g * 0.1192 + rgb2.b * 0.9505
      };
    };
    xyz2Lab = function(xyz1) {
      var k, v, xyz2;
      xyz2 = {
        x: xyz1.x / 95.047,
        y: xyz1.y / 100,
        z: xyz1.z / 108.883
      };
      for (k in xyz2) {
        v = xyz2[k];
        xyz2[k] = v > 0.008856 ? Math.pow(v, 1 / 3) : 7.787 * v + 16 / 116;
      }
      return {
        L: (116 * xyz2.y) - 16,
        a: 500 * (xyz2.x - xyz2.y),
        b: 200 * (xyz2.y - xyz2.z)
      };
    };
    lab1 = xyz2Lab(rgb2xyz(c1));
    lab2 = xyz2Lab(rgb2xyz(c2));
    sum = 0;
    for (k in lab1) {
      v1 = lab1[k];
      v2 = lab2[k];
      delta = v1 - v2;
      sum += delta * delta;
    }
    return Math.sqrt(sum);
  },
  nearestToColourOutOfColours: function(c1, cs) {
    var c2, closestColour, distance, smallestDistance, _i, _len;
    smallestDistance = Infinity;
    for (_i = 0, _len = cs.length; _i < _len; _i++) {
      c2 = cs[_i];
      if ((distance = KCol.colourDistance(c1, c2)) < smallestDistance) {
        closestColour = c2;
        smallestDistance = distance;
      }
    }
    return closestColour;
  },
  brightness: function(c) {
    return Math.sqrt(c.r * c.r * 0.241 + c.g * c.g * 0.691 + c.b * c.b * 0.068);
  },
  rgbRound: function(rgb) {
    return {
      r: Math.round(rgb.r),
      g: Math.round(rgb.g),
      b: Math.round(rgb.b)
    };
  },
  colourFromHexString: function(str) {
    var rgb;
    rgb = str.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    if (rgb) {
      return {
        r: parseInt(rgb[1], 16),
        g: parseInt(rgb[2], 16),
        b: parseInt(rgb[3], 16)
      };
    }
    rgb = str.match(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i);
    if (rgb) {
      return {
        r: parseInt(rgb[1] + rgb[1], 16),
        g: parseInt(rgb[2] + rgb[2], 16),
        b: parseInt(rgb[3] + rgb[3], 16)
      };
    }
    throw "Invalid colour string '" + str + "'";
  },
  hexStringFromColour: function(col) {
    var toTwoHexDigits;
    toTwoHexDigits = function(n) {
      var digits;
      digits = n.toString(16);
      if (digits.length < 2) {
        digits = '0' + digits;
      }
      return digits;
    };
    return "#" + (toTwoHexDigits(col.r)) + (toTwoHexDigits(col.g)) + (toTwoHexDigits(col.b));
  }
};

this.KCol.defaults = {
  k: 3,
  sampleFunc: KCol.randomPixelSamples,
  numSamples: 1000,
  meanAttempts: 50,
  iterations: 35,
  minDistance: 0.38
};

this.KCol.random = Math.random;

//# sourceMappingURL=kcolours.js.map
